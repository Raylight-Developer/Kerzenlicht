//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
bool f_rayLensIntersection(in Ray ray, in Camera_Lens lens, inout float ray_length, out vec3 normal) {
	// Transform ray to camera space
	lens.curvature_radius *= 1.0;
	lens.aperture_radius *= 1.0;
	lens.z_distance *= 1.0;

	vec3 lens_center = (/*camera.position + camera.z_vec * */vec3(0, 0, lens.z_distance));
	vec3 ro = ray.origin - lens_center;

	float a = dot(ray.direction, ray.direction);
	float b = 2.0 * dot(ro, ray.direction);
	float c = dot(ro, ro) - lens.curvature_radius * lens.curvature_radius;
	float t0, t1;

	if (f_quadratic(a,b,c,t0,t1)) {
		float t_dist;
		if (lens.curvature_radius < 0) {
			t_dist = t0;
		}
		else {
			t_dist = t1;
		}

		vec3 hit_point = (ray.origin + ray.direction * t_dist);
		float r2 = hit_point.x * hit_point.x + hit_point.y * hit_point.y;
		if (r2 > lens.aperture_radius * lens.aperture_radius) {
			return false;
		}

		normal = normalize(hit_point - lens_center);
		if (lens.curvature_radius > 0) {
			normal = -normal;
		}
		ray_length = t_dist;
		return true;
	}
	return false;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
bool f_raySphereIntersection(in Ray ray, in Sphere sphere, inout float ray_length) {
	ray.origin = ray.origin - sphere.position;

	float b = dot(ray.origin, ray.direction);
	float delta = b * b - dot(ray.origin, ray.origin) + sphere.diameter * sphere.diameter;
	
	if (delta < 0) {
		return false;
	}
	float sqdelta = sqrt(delta);

	if (-b - sqdelta > EPSILON) {
		ray_length = -b - sqdelta;
		return true;
	}
	else if (-b + sqdelta > EPSILON) {
		ray_length = -b + sqdelta;
		return true;
	}
	return false;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
bool f_rayBvhIntersection(in Ray ray, in Bvh box, inout float ray_length) {
	vec3 f = (box.p_min - ray.origin) * ray.inv_direction;
	vec3 n = (box.p_max - ray.origin) * ray.inv_direction;

	vec3 tmax = max(f, n);
	vec3 tmin = min(f, n);

	float t1 = min(tmax.x, min(tmax.y, tmax.z));
	float t0 = max(tmin.x, max(tmin.y, tmin.z));

	if (t1 >= t0) {
		if (t0 > 0.0f) {
			ray_length = t0;
		}
		else {
			ray_length = t1;
		}
		return true;
	}
	return false;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
bool f_rayTriangleIntersection(in Ray ray, in vec3 vertex_a, in vec3 vertex_b, in vec3 vertex_c, inout float ray_length) {
	vec3 v1v0 = vertex_b - vertex_a;
	vec3 v2v0 = vertex_c - vertex_a;
	vec3 rov0 = ray.origin- vertex_a;

	vec3  normal = cross(v1v0, v2v0);
	vec3  q = cross(rov0, ray.direction);
	float d = 1.0 / dot(ray.direction, normal);
	float u = d * dot(-q, v2v0);
	float v = d * dot(q, v1v0);
	float t = d * dot(-normal, rov0);

	if (u < 0.0 || v < 0.0 || (u + v) > 1.0)
		return false;

	ray_length = t;
	return true;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
bool f_rayTriangleIntersection(in Ray ray, in Triangle tri, inout float ray_length) {
	vec3 v1v0 = tri.pos_b - tri.pos_a;
	vec3 v2v0 = tri.pos_c - tri.pos_a;
	vec3 rov0 = ray.origin- tri.pos_a;

	vec3  normal = cross(v1v0, v2v0);
	vec3  q = cross(rov0, ray.direction);
	float d = 1.0 / dot(ray.direction, normal);
	float u = d * dot(-q, v2v0);
	float v = d * dot(q, v1v0);
	float t = d * dot(-normal, rov0);

	if (u < 0.0 || v < 0.0 || (u + v) > 1.0)
		return false;

	ray_length = t;
	return true;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
float f_rayBvhDist(in Ray ray, in vec3 boxMin, vec3 boxMax) {
	vec3 tMin = (boxMin - ray.origin) * ray.inv_direction;
	vec3 tMax = (boxMax - ray.origin) * ray.inv_direction;
	vec3 t1 = min(tMin, tMax);
	vec3 t2 = max(tMin, tMax);
	float tNear = max(max(t1.x, t1.y), t1.z);
	float tFar = min(min(t2.x, t2.y), t2.z);

	bool hit = tFar >= tNear && tFar > 0;
	float dst = hit ? tNear > 0 ? tNear : 0 : MAX_DIST;
	return dst;
};

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
vec3 f_barycentricCoords(in vec3 hit_pos, in vec3 vertex_a, in vec3 vertex_b, in vec3 vertex_c) {
	vec3 v0 = vertex_b - vertex_a;
	vec3 v1 = vertex_c - vertex_a;
	vec3 v2 = hit_pos  - vertex_a;

	float d00 = dot(v0, v0);
	float d01 = dot(v0, v1);
	float d11 = dot(v1, v1);
	float d20 = dot(v2, v0);
	float d21 = dot(v2, v1);

	float denom = d00 * d11 - d01 * d01;

	float v = (d11 * d20 - d01 * d21) / denom;
	float w = (d00 * d21 - d01 * d20) / denom;
	float u = 1.0 - v - w;

	return vec3(u, v, w);
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
Triangle_Hit_Info f_closestTriangle(in Ray ray, in uint root_node_index, inout Hit hit_data) {
	Triangle_Hit_Info result;
	result.triangle_index = MAX_UINT;
	result.hit_distance = MAX_DIST;

	uint stack[32];
	uint stackIndex = 0;
	stack[stackIndex++] = root_node_index; // + instance offset
	
	while (stackIndex > 0) {
		Bvh node = KL_BUFFER_MESH_BLAS[stack[--stackIndex]];
		bool isLeaf = node.tri_count != MAX_UINT;

		if (isLeaf) {
			for (uint i = 0; i < node.tri_count; i++) {
				Triangle tri = KL_BUFFER_MESH_TRIANGLES[node.pointer + i];
				float dist = MAX_DIST;
				if (f_rayTriangleIntersection(ray, tri, dist)) {
					if (dist < result.hit_distance) {
						result.hit_distance = dist;
						result.triangle_index = node.pointer + i;
					}
				}
			}
		}
		else {
			uint childIndexA = root_node_index + node.pointer + 0;
			uint childIndexB = root_node_index + node.pointer + 1;
			Bvh childA = KL_BUFFER_MESH_BLAS[childIndexA];
			Bvh childB = KL_BUFFER_MESH_BLAS[childIndexB];

			float dstA = f_rayBvhDist(ray, childA.p_min, childA.p_max);
			float dstB = f_rayBvhDist(ray, childB.p_min, childB.p_max);
			hit_data.bvh_depth += 2;

			bool  isNearestA = dstA <= dstB;
			float dstNear = isNearestA ? dstA : dstB;
			float dstFar  = isNearestA ? dstB : dstA;
			uint   childIndexNear = isNearestA ? childIndexA : childIndexB;
			uint   childIndexFar  = isNearestA ? childIndexB : childIndexA;

			if (dstFar  < result.hit_distance) stack[stackIndex++] = childIndexFar;
			if (dstNear < result.hit_distance) stack[stackIndex++] = childIndexNear;
		}
	}

	return result;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
void f_sceneIntersection(in Ray ray, inout Hit hit_data) {
	float t_dist = MAX_DIST;
	float bvh_t_length = MAX_DIST;

	for (uint i = 0; i <= KL_BUFFER_MESH_INSTANCES.length(); i++) { // TODO i <= WHY ????
		Triangle_Hit_Info triangle_hit = f_closestTriangle(ray, KL_BUFFER_MESH_INSTANCES[i].object_index, hit_data);
		if (triangle_hit.triangle_index != MAX_UINT) {
			Triangle tri = KL_BUFFER_MESH_TRIANGLES[triangle_hit.triangle_index];
			hit_data.t_dist = triangle_hit.hit_distance;
			hit_data.hit_pos = ray.origin + ray.direction * ( triangle_hit.hit_distance - EPSILON);
			hit_data.inside = false;
			hit_data.mesh_hit = true;

			hit_data.uvw = f_barycentricCoords(
				hit_data.hit_pos,
				tri.pos_a,
				tri.pos_b,
				tri.pos_c
			);
			hit_data.material = tri.material;

			hit_data.hit_tri = tri;
			hit_data.hit_normal = hit_data.uvw.x * tri.normal_a + hit_data.uvw.y * tri.normal_b + hit_data.uvw.z * tri.normal_c;
		}
	}
}
bool f_rayLensIntersection(in Ray ray, in Camera_Lens lens, inout float ray_length, out vec3 normal) {
	// Transform ray to camera space
	lens.curvature_radius *= 5.0;
	lens.aperture_radius *= 5.0;
	lens.z_distance *= 5.0;
	vec3 ray_origin_cam = ray.origin - camera.position;
	vec3 ray_dir_cam = vec3(
		dot(ray.direction, camera.x_vec),
		dot(ray.direction, camera.y_vec),
		dot(ray.direction, camera.z_vec)
	);
	vec3 ray_origin_trans = vec3(
		dot(ray_origin_cam, camera.x_vec),
		dot(ray_origin_cam, camera.y_vec),
		dot(ray_origin_cam, camera.z_vec)
	);

	// Transform the lens to camera space
	vec3 o = ray_origin_trans - vec3(0, 0, lens.z_distance);
	
	float A = ray_dir_cam.x * ray_dir_cam.x + ray_dir_cam.y * ray_dir_cam.y + ray_dir_cam.z * ray_dir_cam.z;
	float B = 2.0 * (ray_dir_cam.x * o.x + ray_dir_cam.y * o.y + ray_dir_cam.z * o.z);
	float C = o.x * o.x + o.y * o.y + o.z * o.z - lens.curvature_radius * lens.curvature_radius;
	float t0, t1;
	
	if (!f_quadratic(A, B, C, t0, t1)) {
		return false;
	}

	float t_dist = 0.0;
	bool useCloserT = (ray_dir_cam.z > 0.0) && (lens.curvature_radius < 0.0);
	t_dist = useCloserT ? min(t0, t1) : max(t0, t1);
	
	if (t_dist < 0.0) {
		return false;
	}

	vec3 hit_point_cam = ray_origin_trans + ray_dir_cam * t_dist;
	float r2 = hit_point_cam.x * hit_point_cam.x + hit_point_cam.y * hit_point_cam.y;
	if (r2 > lens.aperture_radius * lens.aperture_radius) {
		return false;
	}

	ray_length = t_dist;

	// Compute normal at the hit point
	normal = normalize(vec3(o + ray_length * ray_dir_cam));
	normal = f_faceForward(normal, -ray_dir_cam);

	return true;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
bool f_rayBvhIntersection(in Ray ray, in Bvh box, inout float ray_length) {
	vec3 f = (box.p_min - ray.origin) * ray.direction;
	vec3 n = (box.p_max - ray.origin) * ray.direction;

	vec3 tmax = max(f, n);
	vec3 tmin = min(f, n);

	float t1 = min(tmax.x, min(tmax.y, tmax.z));
	float t0 = max(tmin.x, max(tmin.y, tmin.z));

	if (t1 >= t0) {
		if (t0 > 0.0f) {
			ray_length = t0;
		}
		else {
			ray_length = t1;
		}
		return true;
	}
	return false;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
bool f_rayTriangleIntersection(in Ray ray, in vec3 vertex_a, in vec3 vertex_b, in vec3 vertex_c, inout float ray_length) {
	vec3 v1v0 = vertex_b - vertex_a;
	vec3 v2v0 = vertex_c - vertex_a;
	vec3 rov0 = ray.origin- vertex_a;

	vec3  normal = cross(v1v0, v2v0);
	vec3  q = cross(rov0, ray.direction);
	float d = 1.0 / dot(ray.direction, normal);
	float u = d * dot(-q, v2v0);
	float v = d * dot(q, v1v0);
	float t = d * dot(-normal, rov0);

	if (u < 0.0 || v < 0.0 || (u + v) > 1.0)
		return false;

	ray_length = t;
	return true;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
vec3 f_barycentricCoords(in vec3 hit_pos, in vec3 vertex_a, in vec3 vertex_b, in vec3 vertex_c) {
	vec3 v0 = vertex_b - vertex_a;
	vec3 v1 = vertex_c - vertex_a;
	vec3 v2 = hit_pos  - vertex_a;

	float d00 = dot(v0, v0);
	float d01 = dot(v0, v1);
	float d11 = dot(v1, v1);
	float d20 = dot(v2, v0);
	float d21 = dot(v2, v1);

	float denom = d00 * d11 - d01 * d01;

	float v = (d11 * d20 - d01 * d21) / denom;
	float w = (d00 * d21 - d01 * d20) / denom;
	float u = 1.0 - v - w;

	return vec3(u, v, w);
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
void f_sceneIntersection(in Ray ray, inout Hit hit_data) {
	float t_dist = MAX_DIST;
	float bvh_t_length = MAX_DIST;

	Ray bvh_ray = Ray(ray.origin, 1.0 / ray.direction);

	// Bvh Top-Down traversal
	for (uint i = 0; i < bvh_nodes.length(); i++) {
		Bvh node = bvh_nodes[i];
		if (f_rayBvhIntersection(
			bvh_ray,
			node,
			bvh_t_length
		)) {
			if (bvh_t_length < MAX_DIST && bvh_t_length > EPSILON) {
				hit_data.bvh_depth++;
				if (node.tri_count > 0) {
					for (uint i = node.pointer; i < node.pointer + node.tri_count; i++) {
						Triangle tri = triangles[i];
						if (f_rayTriangleIntersection(
							ray,
							tri.pos_a,
							tri.pos_b,
							tri.pos_c,
							t_dist
						)) {
							if (t_dist < hit_data.t_dist && t_dist > EPSILON) {
								hit_data.t_dist = t_dist;
								hit_data.hit_pos = ray.origin + ray.direction * (t_dist - EPSILON);
								hit_data.inside = false;
								hit_data.mesh_hit = true;
					
								hit_data.uvw = f_barycentricCoords(
									hit_data.hit_pos,
									tri.pos_a,
									tri.pos_b,
									tri.pos_c
								);
								hit_data.material = tri.material;
					
								hit_data.hit_tri = tri;
								hit_data.hit_normal = hit_data.uvw.x * tri.normal_a + hit_data.uvw.y * tri.normal_b + hit_data.uvw.z * tri.normal_c;
							}
						}
					}
				}
			}
		}
	}
}
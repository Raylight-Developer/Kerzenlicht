//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
#version 460
// INTERNAL ---------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
struct Medium {
	uint  type;
	float density;
	vec3  color;
	float anisotropy;
};
// LINK -------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
struct Camera {
	float focal_distance;
	float ortho_scale;
	float aperture;
	float fov;
	vec3  position;
	vec3  x_vec;
	vec3  y_vec;
	vec3  z_vec;
	vec3  p_uv;
	vec3  p_u;
	vec3  p_v;
};
struct Camera_Lens {
	float curvature_radius;
	float aperture_radius;
	float z_distance;
	float ior;
};
struct Triangle {
	vec3  pos_a;
	float uv_a_x;
	vec3  normal_a;
	float uv_a_y;
	// 32
	vec3  pos_b;
	float uv_b_x;
	vec3  normal_b;
	float uv_b_y;
	// 64
	vec3  pos_c;
	float uv_c_x;
	vec3  normal_c;
	float uv_c_y;
	// 96
	vec3  padding;
	uint  material;
	// 112
};
struct Bvh {
	vec3 p_min;
	uint pointer;
	vec3 p_max;
	uint tri_count; // If == 0, pointer leads to other Bvh Node, else leads to Triangle Start Index
	// 32
};
struct Texture {
	uint start;
	uint width;
	uint height;
	uint format;
	// 16
};
struct Point_Light {
	vec3  pos;
	float radius;
	vec3  color;
	float intentsity;
	// 32
};
struct Directional_Light {
	vec3  rotation;
	float angle;
	vec3  color;
	float intentsity;
	// 32
};
struct Material {
	vec3  baseColor;
	float opacity;
	uint  alphaMode;
	float alphaCutoff;
	vec3  emission;
	float anisotropic;
	float metallic;
	float roughness;
	float subsurface;
	float specularTint;
	float sheen;
	float sheenTint;
	float clearcoat;
	float clearcoatRoughness;
	float specTrans;
	float ior;
	float ax;
	float ay;
	Medium medium;
};
// DEFINITIONS ------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
#define TWO_PI   6.28318530718
#define PI       3.14159265359
#define HALF_PI  1.57079632679
#define INV_PI   0.31830988618
#define DEG_RAD  0.01745329252
#define RAD_DEG  0.01745329252
#define MAX_DIST 10000.0
#define EPSILON  0.0001
#define INF 1000000.0
#define MAX_UINT 4294967295
#define QUAD_LIGHT 0
#define SPHERE_LIGHT 1
#define DISTANT_LIGHT 2
#define MEDIUM_NONE 0
#define MEDIUM_ABSORB 1
#define MEDIUM_SCATTER 2
#define MEDIUM_EMISSIVE 3
#define ALPHA_MODE_OPAQUE 0
#define ALPHA_MODE_BLEND 1
#define ALPHA_MODE_MASK 2
// INTERNAL ---------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
struct Ray {
	vec3 origin;
	vec3 direction;
};
struct Sphere {
	vec3  position;
	float diameter;
};
struct Hit {
	bool  error;
	float t_dist;
	bool  inside;
	bool  mesh_hit;
	uint  bvh_depth;
	uint  material;
	vec3  hit_pos;
	vec3  hit_normal;
	vec3  uvw;
	float pdf;
	Triangle hit_tri;
};
Hit f_hit() {
	Hit hit;
	hit.error = false;
	hit.mesh_hit = false;
	hit.hit_normal = vec3(0);
	hit.bvh_depth = 0;
	hit.material = 0;
	hit.pdf = 0;
	hit.t_dist = MAX_DIST;
	return hit;
}
struct State {
	uint  depth;
	float eta;
	float hitDist;
	vec3  fhp;
	vec3  normal;
	vec3  ffnormal;
	vec3  tangent;
	vec3  bitangent;
	bool  isEmitter;
	vec2  texCoord;
	uint  matID;
	Medium medium;
	Material material;
};
struct BsdfSampleRec {
	vec3  L;
	vec3  f;
	float pdf;
};
struct LightSampleRec {
	vec3  normal;
	vec3  emission;
	vec3  direction;
	float dist;
	float pdf;
};
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;
layout(rgba32f, binding = 0)           uniform image2D accumulation_render_layer;
layout(rgba32f, binding = 1) writeonly uniform image2D raw_render_layer;
layout(rgba32f, binding = 2) writeonly uniform image2D bvh_render_layer;
layout(rgba32f, binding = 3) writeonly uniform image2D normal_render_layer;
layout(std430, binding = 5) buffer TriangleBuffer {
	Triangle triangles[];
};
layout(std430, binding = 6) buffer BvhBuffer {
	Bvh bvh_nodes[];
};
layout(std430, binding = 7) buffer TextureBuffer {
	Texture textures[];
};
layout(std430, binding = 8) buffer TextureDataBuffer {
	uint texture_data[];
};
layout(std430, binding = 9) buffer CameraLensesBuffer {
	Camera_Lens camera_lenses[];
};
layout(std430, binding = 10) buffer PointLightBuffer {
	Point_Light point_lights[];
};
layout(std430, binding = 11) buffer DirectionalLightBuffer {
	Directional_Light directional_lights[];
};
uniform uint  frame_count;
uniform float aspect_ratio;
uniform float current_time;
uniform uvec2 resolution;
uniform bool  debug;
uniform uint  current_sample;
uniform uint  ray_bounces;
uniform uint  samples_per_pixel;
uniform Camera camera;
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
float f_lerp(in float a,in float b, in float t) {
	return a + t * (b - a);
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
vec3 f_lerp(in vec3 a,in vec3 b, in float t) {
	return a + t * (b - a);
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
float f_mapFloat(float from_min, float from_max, float to_min, float to_max, float value) {
	return (to_min + ((to_max - to_min) / (from_max - from_min)) * (value - from_min));
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
float f_mapFloatClamp(float from_min, float from_max, float to_min, float to_max, float value) {
	if (value > from_max) return to_max;
	else if (value < from_min) return to_min;
	else return (to_min + ((to_max - to_min) / (from_max - from_min)) * (value - from_min));
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
vec2 f_mapVec2(vec2 from_min, vec2 from_max, vec2 to_min, vec2 to_max, vec2 value) {
	return vec2(f_mapFloat(from_min.x, from_max.x, to_min.x, to_max.x, value.x), f_mapFloat(from_min.y, from_max.y, to_min.y, to_max.y, value.y));
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
vec3 f_faceForward(vec3 a, vec3 b) {
	return dot(a, b) < 0.0 ? -b : b;
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
float f_luminance(vec3 c) {
	return 0.212671 * c.x + 0.715160 * c.y + 0.072169 * c.z;
}
bool f_quadratic(float A, float B, float C, out float t0, out float t1) {
	float discriminant = B * B - 4.0 * A * C;
	if (discriminant < 0.0) {
		return false;
	}
	float sqrt_discriminant = sqrt(discriminant);
	t0 = (-B - sqrt_discriminant) / (2.0 * A);
	t1 = (-B + sqrt_discriminant) / (2.0 * A);
	return true;
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
vec4 sampleTextureRgba8u(in Texture tex, in vec2 uv) {
	uint x = uint(uv.x * float(tex.width));
	uint y = uint(uv.y * float(tex.height));
	x = clamp(x, 0, tex.width - 1);
	y = clamp(y, 0, tex.height - 1);
	uint index = tex.start + y * tex.width + x;
	uint color = texture_data[index];
	return vec4(
		float((color >> 24) & 0xFF) / 255.0,
		float((color >> 16) & 0xFF) / 255.0,
		float((color >> 8) & 0xFF) / 255.0,
		float(color & 0xFF) / 255.0
	);
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
vec4 sampleTextureRgba16f(in Texture tex, in vec2 uv) {
	uint x = uint(uv.x * float(tex.width));
	uint y = uint(uv.y * float(tex.height));
	x = clamp(x, 0, tex.width - 1);
	y = clamp(y, 0, tex.height - 1);
	uint index = tex.start + (y * tex.width + x) * 2;
	uint color_a = texture_data[index];
	uint color_b = texture_data[index+1];
	vec2 rg = unpackHalf2x16(color_a);
	vec2 ba = unpackHalf2x16(color_b);
	return vec4(
		rg.x,
		rg.y,
		ba.x,
		ba.y
	);
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
vec4 sampleTextureRgba32f(in Texture tex, in vec2 uv) {
	uint x = uint(uv.x * float(tex.width));
	uint y = uint(uv.y * float(tex.height));
	x = clamp(x, 0, tex.width - 1);
	y = clamp(y, 0, tex.height - 1);
	uint index = tex.start + (y * tex.width + x) * 4;
	return vec4(
		texture_data[index],
		texture_data[index + 1],
		texture_data[index + 2],
		texture_data[index + 3]
	);
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
vec2 f_getUV(Hit hit_data) {
	return hit_data.uvw.x * vec2(hit_data.hit_tri.uv_a_x, hit_data.hit_tri.uv_a_y) +
	hit_data.uvw.y * vec2(hit_data.hit_tri.uv_b_x, hit_data.hit_tri.uv_b_y) +
	hit_data.uvw.z * vec2(hit_data.hit_tri.uv_c_x, hit_data.hit_tri.uv_c_y);
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
uvec4 seed;
ivec2 pixel;
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
void f_initRNG(ivec2 p, uint frame) {
	seed = uvec4(p.x, p.y, frame, uint(p.x) + uint(p.y));
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
void f_pcg4d(inout uvec4 v) {
	v = v * 1664525u + 1013904223u;
	v.x += v.y * v.w; v.y += v.z * v.x; v.z += v.x * v.y; v.w += v.y * v.z;
	v = v ^ (v >> 16u);
	v.x += v.y * v.w; v.y += v.z * v.x; v.z += v.x * v.y; v.w += v.y * v.z;
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
float f_rand() {
	f_pcg4d(seed); return float(seed.x) / float(0xffffffffu);
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
vec2 f_randUnitDisk() {
	vec2 p;
		do {
			p = 2.0 * vec2(f_rand(), f_rand()) - vec2(1.0, 1.0);
		} while (dot(p, p) >= 1.0);
	return p;
}
bool f_rayLensIntersection(in Ray ray, in Camera_Lens lens, inout float ray_length, out vec3 normal) {
	vec3  o = ray.origin - vec3(0, 0, lens.z_distance);

	float A = ray.direction.x * ray.direction.x + ray.direction.y * ray.direction.y + ray.direction.z * ray.direction.z;
	float B = 2 * (ray.direction.x * o.x + ray.direction.y * o.y + ray.direction.z * o.z);
	float C = o.x * o.x + o.y * o.y + o.z * o.z - lens.curvature_radius * lens.curvature_radius;
	float t0, t1;

	if (!f_quadratic(A, B, C, t0, t1)) {
		return false;
	}

	float t_dist = 0;

	bool useCloserT = (ray.direction.z > 0) && (lens.curvature_radius < 0);
	t_dist = useCloserT ? min(t0, t1) : max(t0, t1);
	if (t_dist < 0) {

		return false;
	}

	vec3 hit_point = ray.origin + ray.direction * t_dist;
	float r2 = hit_point.x * hit_point.x + hit_point.y * hit_point.y;
	if (r2 > lens.aperture_radius * lens.aperture_radius) {
		return false;
	}

	ray_length = t_dist;

	normal = normalize(vec3(o + ray_length * ray.direction));
	normal = f_faceForward(normal, -ray.direction);

	return true;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
bool f_raySphereIntersection(in Ray ray, in Sphere sphere, inout float ray_length) {
	ray.origin = ray.origin - sphere.position;

	float b = dot(ray.origin, ray.direction);
	float delta = b * b - dot(ray.origin, ray.origin) + sphere.diameter * sphere.diameter;
	
	if (delta < 0) {
		return false;
	}
	float sqdelta = sqrt(delta);

	if (-b - sqdelta > EPSILON) {
		ray_length = -b - sqdelta;
		return true;
	}
	else if (-b + sqdelta > EPSILON) {
		ray_length = -b + sqdelta;
		return true;
	}
	return false;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
bool f_rayBvhIntersection(in Ray ray, in Bvh box, inout float ray_length) {
	vec3 f = (box.p_min - ray.origin) * ray.direction;
	vec3 n = (box.p_max - ray.origin) * ray.direction;

	vec3 tmax = max(f, n);
	vec3 tmin = min(f, n);

	float t1 = min(tmax.x, min(tmax.y, tmax.z));
	float t0 = max(tmin.x, max(tmin.y, tmin.z));

	if (t1 >= t0) {
		if (t0 > 0.0f) {
			ray_length = t0;
		}
		else {
			ray_length = t1;
		}
		return true;
	}
	return false;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
bool f_rayTriangleIntersection(in Ray ray, in vec3 vertex_a, in vec3 vertex_b, in vec3 vertex_c, inout float ray_length) {
	vec3 v1v0 = vertex_b - vertex_a;
	vec3 v2v0 = vertex_c - vertex_a;
	vec3 rov0 = ray.origin- vertex_a;

	vec3  normal = cross(v1v0, v2v0);
	vec3  q = cross(rov0, ray.direction);
	float d = 1.0 / dot(ray.direction, normal);
	float u = d * dot(-q, v2v0);
	float v = d * dot(q, v1v0);
	float t = d * dot(-normal, rov0);

	if (u < 0.0 || v < 0.0 || (u + v) > 1.0)
		return false;

	ray_length = t;
	return true;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
vec3 f_barycentricCoords(in vec3 hit_pos, in vec3 vertex_a, in vec3 vertex_b, in vec3 vertex_c) {
	vec3 v0 = vertex_b - vertex_a;
	vec3 v1 = vertex_c - vertex_a;
	vec3 v2 = hit_pos  - vertex_a;

	float d00 = dot(v0, v0);
	float d01 = dot(v0, v1);
	float d11 = dot(v1, v1);
	float d20 = dot(v2, v0);
	float d21 = dot(v2, v1);

	float denom = d00 * d11 - d01 * d01;

	float v = (d11 * d20 - d01 * d21) / denom;
	float w = (d00 * d21 - d01 * d20) / denom;
	float u = 1.0 - v - w;

	return vec3(u, v, w);
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
void f_sceneIntersection(in Ray ray, inout Hit hit_data) {
	float t_dist = MAX_DIST;
	float bvh_t_length = MAX_DIST;

	Ray bvh_ray = Ray(ray.origin, 1.0 / ray.direction);

	// Bvh Top-Down traversal
	for (uint i = 0; i < bvh_nodes.length(); i++) {
		Bvh node = bvh_nodes[i];
		if (f_rayBvhIntersection(
			bvh_ray,
			node,
			bvh_t_length
		)) {
			if (bvh_t_length < MAX_DIST && bvh_t_length > EPSILON) {
				hit_data.bvh_depth++;
				if (node.tri_count > 0) {
					for (uint i = node.pointer; i < node.pointer + node.tri_count; i++) {
						Triangle tri = triangles[i];
						if (f_rayTriangleIntersection(
							ray,
							tri.pos_a,
							tri.pos_b,
							tri.pos_c,
							t_dist
						)) {
							if (t_dist < hit_data.t_dist && t_dist > EPSILON) {
								hit_data.t_dist = t_dist;
								hit_data.hit_pos = ray.origin + ray.direction * (t_dist - EPSILON);
								hit_data.inside = false;
								hit_data.mesh_hit = true;
					
								hit_data.uvw = f_barycentricCoords(
									hit_data.hit_pos,
									tri.pos_a,
									tri.pos_b,
									tri.pos_c
								);
								hit_data.material = tri.material;
					
								hit_data.hit_tri = tri;
								hit_data.hit_normal = hit_data.uvw.x * tri.normal_a + hit_data.uvw.y * tri.normal_b + hit_data.uvw.z * tri.normal_c;
							}
						}
					}
				}
			}
		}
	}
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
vec4 f_hook(inout Hit hit_data, inout State state, inout Ray ray) {
	if (hit_data.material == MAX_UINT) {
		ray.direction = reflect(ray.direction, hit_data.hit_normal);
		ray.origin = hit_data.hit_pos + ray.direction * EPSILON;
		return vec4(0.9, 0.9, 0.9, 1.0);
	}
	else if (hit_data.material == 0) {
		vec2 uv = f_getUV(hit_data);
		vec4 albedo = vec4(0,0,0,1);
		if (hit_data.mesh_hit) {
			albedo = sampleTextureRgba8u(textures[0], vec2(uv.x, 1 - uv.y));
		}
		Material ganyu_material = Material(
			vec3(1.0)        , // baseColor
			1.0              , // opacity
			ALPHA_MODE_OPAQUE, // alphaMode
			1.0              , // alphaCutoff
			vec3(0.0)        , // emission
			1.0              , // anisotropic
			1.0              , // metallic
			1.0              , // roughness
			1.0              , // subsurface
			1.0              , // specularTint
			1.0              , // sheen
			1.0              , // sheenTint
			1.0              , // clearcoat
			1.0              , // clearcoatRoughness
			1.0              , // specTrans
			1.0              , // ior
			1.0              , // ax
			1.0              , // ay
			Medium(
				MEDIUM_NONE, // type
				1.0,         // density
				vec3(1.0),   // color
				1.0          // anisotropy
			)
		);
		state.material = ganyu_material;
		return albedo;
	}
	// ERROR
	hit_data.error = true;
	return vec4(1, 0, 1, 1);
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
Ray f_cameraNormRay(vec2 uv) {
	return Ray(camera.position, normalize(camera.p_uv + (camera.p_u * uv.x) + (camera.p_v * uv.y) - camera.position));
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
Ray f_cameraRay(vec2 uv) {
	float pixel_size = 1.0 / resolution.x;

	vec3 ray_dir = normalize(camera.p_uv + (camera.p_u * uv.x) + (camera.p_v * uv.y) - camera.position);
	vec3 focal_point = camera.position + ray_dir * camera.focal_distance;

	vec2 aperture_offset = f_randUnitDisk() * pixel_size * camera.aperture * 0.5;
	vec3 lens_offset = camera.position + camera.x_vec * aperture_offset.x + camera.y_vec * aperture_offset.y;
	vec3 new_direction = normalize(focal_point - lens_offset);

	return Ray(camera.position, new_direction);
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
Ray f_cameraOrthoRay(vec2 uv) {
	float ortho_scale = 0.1;
	return Ray(camera.position + (camera.p_u * uv.x * ortho_scale) + (camera.p_v * uv.y* ortho_scale), camera.z_vec);
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
vec4 f_pathTrace(in Ray ray, in ivec2 pixel_id) {
	vec3 radiance = vec3(0.0);
	vec3 throughput = vec3(1.0);
	State state;
	LightSampleRec lightSample;
	BsdfSampleRec bsdfSample;

	vec4 render_output = vec4(0);

	Hit hit_data = f_hit();
	f_sceneIntersection(ray, hit_data);

	render_output = f_hook(hit_data, state, ray);


	return render_output;
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
void f_debugRender(in vec2 uv, in ivec2 pixel_id) {
	Ray ray = f_cameraNormRay(uv);
	Hit hit_data = f_hit();
	f_sceneIntersection(ray, hit_data);

	float bvh_alpha = 1.0;
	for (int i = 0; i < hit_data.bvh_depth; i++) {
		bvh_alpha *= 0.95;
	}
	imageStore(bvh_render_layer, pixel_id, vec4(vec3(1-bvh_alpha), 1));
	imageStore(normal_render_layer, pixel_id, vec4(abs(hit_data.hit_normal), 1));
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
void f_accumulate(in vec4 color, in ivec2 pixel_id) {
	vec4 previous_color = imageLoad(accumulation_render_layer, pixel_id);
	if (current_sample == 0) {
		previous_color = vec4(0);
	}

	float weight = float(current_sample);
	vec4 full_color = (previous_color * weight + color) / (weight + 1.0);
	imageStore(accumulation_render_layer, pixel_id, vec4(full_color.rgb / full_color.a, 1.0));
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
vec4 f_render(in vec2 uv, in ivec2 pixel_id) {
	f_debugRender(uv, pixel_id);

	Ray ray = f_cameraRay(uv);
	vec4 pixel_color = vec4(0);


	float t_dist = MAX_DIST;
	vec3 normal;
	for (uint i = 0; i < camera_lenses.length(); i++) {
		t_dist = MAX_DIST;
		if (f_rayLensIntersection(ray, camera_lenses[i], t_dist, normal)) {
			pixel_color += vec4(normal, 0.5);
			ray.origin = ray.origin + ray.direction * t_dist;
			ray.direction = normalize(refract(ray.direction, normal, camera_lenses[i].ior));
		}
	}

	//float t_dist = MAX_DIST;
	//Sphere sphere = Sphere(vec3(0, 0, 1), 0.5);
	//if (f_raySphereIntersection(ray, sphere, t_dist)) {
	//	vec3 normal = normalize(ray.direction * t_dist - sphere.position);
	//	pixel_color = vec4(normal, 1);
	//	//ray.origin = ray.direction * (t_dist + EPSILON);
	//	ray.direction = normalize(refract(ray.direction, normal, 1.0));
	//}



	pixel_color += f_pathTrace(ray, pixel_id);
	f_accumulate(pixel_color, pixel_id);

	return pixel_color;
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
void main() {
	ivec2 pixel_id = ivec2(gl_GlobalInvocationID.xy);
	vec2 uv = (pixel_id - 1 - vec2(resolution) / 2.0) / float(max(resolution.x, resolution.y));
	f_initRNG(pixel_id, frame_count);
	vec4 pixel_color = f_render(uv, pixel_id);
	imageStore(raw_render_layer, pixel_id, pixel_color);
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
#version 460
// INTERNAL ---------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
struct Medium {
	uint  type;
	float density;
	vec3  color;
	float anisotropy;
};
// LINK -------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
struct Camera {
	float focal_distance;
	float ortho_scale;
	float aperture;
	float fov;
	vec3  position;
	vec3  x_vec;
	vec3  y_vec;
	vec3  z_vec;
	vec3  p_uv;
	vec3  p_u;
	vec3  p_v;
};
struct Camera_Lens {
	float curvature_radius; // circle radius. if positive, viewing from inside(convex), if negative, viewing from outside(concave)
	float aperture_radius; // cutoff radius
	float z_distance; // distance of sphere center from camera
	float ior; // surface IOR
};
struct Object_Instance {
	uint object_index;
	vec3 padding;
	// 16
};
struct Triangle {
	vec3  pos_a;
	float uv_a_x;
	vec3  normal_a;
	float uv_a_y;
	// 32
	vec3  pos_b;
	float uv_b_x;
	vec3  normal_b;
	float uv_b_y;
	// 64
	vec3  pos_c;
	float uv_c_x;
	vec3  normal_c;
	float uv_c_y;
	// 96
	vec3  padding;
	uint  material;
	// 112
};
struct Bvh {
	vec3 p_min;
	uint pointer;
	vec3 p_max;
	uint tri_count; // If == 0, pointer leads to other Bvh Node, else leads to Triangle Start Index
	// 32
};
struct Texture {
	uint start;
	uint width;
	uint height;
	uint format;
	// 16
};
struct Point_Light {
	vec3  pos;
	float radius;
	vec3  color;
	float intentsity;
	// 32
};
struct Directional_Light {
	vec3  rotation;
	float angle;
	vec3  color;
	float intentsity;
	// 32
};
struct Material {
	vec3  baseColor;
	float opacity;
	uint  alphaMode;
	float alphaCutoff;
	vec3  emission;
	float anisotropic;
	float metallic;
	float roughness;
	float subsurface;
	float specularTint;
	float sheen;
	float sheenTint;
	float clearcoat;
	float clearcoatRoughness;
	float specTrans;
	float ior;
	float ax;
	float ay;
	Medium medium;
};
// DEFINITIONS ------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
#define TWO_PI   6.28318530718
#define PI       3.14159265359
#define HALF_PI  1.57079632679
#define INV_PI   0.31830988618
#define DEG_RAD  0.01745329252
#define RAD_DEG  0.01745329252
#define MAX_DIST 10000.0
#define EPSILON  0.0001
#define INF 1000000.0
#define MAX_UINT 4294967295
#define QUAD_LIGHT 0
#define SPHERE_LIGHT 1
#define DISTANT_LIGHT 2
#define MEDIUM_NONE 0
#define MEDIUM_ABSORB 1
#define MEDIUM_SCATTER 2
#define MEDIUM_EMISSIVE 3
#define ALPHA_MODE_OPAQUE 0
#define ALPHA_MODE_BLEND 1
#define ALPHA_MODE_MASK 2
// INTERNAL ---------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------------------
struct Ray {
	vec3 origin;
	vec3 direction;
	vec3 inv_direction;
};
struct Sphere {
	vec3  position;
	float diameter;
};
struct Triangle_Hit_Info {
	uint  triangle_index;
	float hit_distance;
};
struct Hit {
	bool  error;
	float t_dist;
	bool  inside;
	bool  mesh_hit;
	uint  bvh_depth;
	uint  material;
	vec3  hit_pos;
	vec3  hit_normal;
	vec3  uvw;
	float pdf;
	Triangle hit_tri;
};
Hit f_hit() {
	Hit hit;
	hit.error = false;
	hit.mesh_hit = false;
	hit.hit_normal = vec3(0);
	hit.bvh_depth = 0;
	hit.material = MAX_UINT;
	hit.pdf = 0;
	hit.t_dist = MAX_DIST;
	return hit;
}
struct State {
	uint  depth;
	float eta;
	float hitDist;
	vec3  fhp;
	vec3  normal;
	vec3  ffnormal;
	vec3  tangent;
	vec3  bitangent;
	bool  isEmitter;
	vec2  texCoord;
	uint  matID;
	Medium medium;
	Material material;
};
struct BsdfSampleRec {
	vec3  L;
	vec3  f;
	float pdf;
};
struct LightSampleRec {
	vec3  normal;
	vec3  emission;
	vec3  direction;
	float dist;
	float pdf;
};
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;
layout(rgba32f, binding = 0)           uniform image2D accumulation_render_layer;
layout(rgba32f, binding = 1) writeonly uniform image2D raw_render_layer;
layout(rgba32f, binding = 2) writeonly uniform image2D bvh_render_layer;
layout(rgba32f, binding = 3) writeonly uniform image2D normal_render_layer;
layout(std430, binding = 4) buffer Mesh_Instance_Buffer {
	Object_Instance mesh_instances[];
};
layout(std430, binding = 5) buffer Mesh_Triangle_Buffer {
	Triangle mesh_triangles[];
};
layout(std430, binding = 6) buffer Mesh_Bvh_Buffer {
	Bvh mesh_bvh[];
};
layout(std430, binding = 7) buffer Texture_Buffer {
	Texture textures[];
};
layout(std430, binding = 8) buffer Texture_Data_Buffer {
	uint texture_data[];
};
layout(std430, binding = 9) buffer Camera_Lenses_Buffer {
	Camera_Lens camera_lenses[];
};
layout(std430, binding = 10) buffer Point_Light_Buffer {
	Point_Light point_lights[];
};
layout(std430, binding = 11) buffer Directional_Light_Buffer {
	Directional_Light directional_lights[];
};
uniform uint  frame_count;
uniform float aspect_ratio;
uniform float current_time;
uniform uvec2 resolution;
uniform bool  debug;
uniform uint  current_sample;
uniform uint  ray_bounces;
uniform uint  samples_per_pixel;
uniform Camera camera;
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
float f_lerp(in float a,in float b, in float t) {
	return a + t * (b - a);
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
vec3 f_lerp(in vec3 a,in vec3 b, in float t) {
	return a + t * (b - a);
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
float f_mapFloat(float from_min, float from_max, float to_min, float to_max, float value) {
	return (to_min + ((to_max - to_min) / (from_max - from_min)) * (value - from_min));
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
float f_mapFloatClamp(float from_min, float from_max, float to_min, float to_max, float value) {
	if (value > from_max) return to_max;
	else if (value < from_min) return to_min;
	else return (to_min + ((to_max - to_min) / (from_max - from_min)) * (value - from_min));
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
vec2 f_mapVec2(vec2 from_min, vec2 from_max, vec2 to_min, vec2 to_max, vec2 value) {
	return vec2(f_mapFloat(from_min.x, from_max.x, to_min.x, to_max.x, value.x), f_mapFloat(from_min.y, from_max.y, to_min.y, to_max.y, value.y));
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
vec3 f_faceForward(vec3 a, vec3 b) {
	return dot(a, b) < 0.0 ? -b : b;
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
float f_luminance(vec3 c) {
	return 0.212671 * c.x + 0.715160 * c.y + 0.072169 * c.z;
}
bool f_quadratic(float A, float B, float C, out float t0, out float t1) {
	float discriminant = B * B - 4.0 * A * C;
	if (discriminant < 0.0) {
		return false;
	}
	float sqrt_discriminant = sqrt(discriminant);
	t0 = (-B - sqrt_discriminant) / (2.0 * A);
	t1 = (-B + sqrt_discriminant) / (2.0 * A);
	return true;
}
vec3 f_refract(vec3 rayDirection, vec3 normal, float iorInside, float iorOutside) {
	float cosi = clamp(dot(normal, -rayDirection), -1.0, 1.0);
	float etai = iorInside;
	float etat = iorOutside;
	// Check if we are entering or exiting
	if (cosi > 0.0) {
		// Swap IORs if we're entering the sphere
		float temp = etai;
		etai = etat;
		etat = temp;
		normal = -normal; // Flip the normal when exiting
	}
	float eta = etai / etat;
	float k = 1.0 - eta * eta * (1.0 - cosi * cosi);
	if (k < 0.0) {
		// Total internal reflection; return no valid refracted ray
		return vec3(0.0); // This could be a direction to handle reflection instead
	} else {
		return eta * rayDirection + (eta * cosi - sqrt(k)) * normal;
	}
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
vec4 sampleTextureRgba8u(in Texture tex, in vec2 uv) {
	uint x = uint(uv.x * float(tex.width));
	uint y = uint(uv.y * float(tex.height));
	x = clamp(x, 0, tex.width - 1);
	y = clamp(y, 0, tex.height - 1);
	uint index = tex.start + y * tex.width + x;
	uint color = texture_data[index];
	return vec4(
		float((color >> 24) & 0xFF) / 255.0,
		float((color >> 16) & 0xFF) / 255.0,
		float((color >> 8) & 0xFF) / 255.0,
		float(color & 0xFF) / 255.0
	);
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
vec4 sampleTextureRgba16f(in Texture tex, in vec2 uv) {
	uint x = uint(uv.x * float(tex.width));
	uint y = uint(uv.y * float(tex.height));
	x = clamp(x, 0, tex.width - 1);
	y = clamp(y, 0, tex.height - 1);
	uint index = tex.start + (y * tex.width + x) * 2;
	uint color_a = texture_data[index];
	uint color_b = texture_data[index+1];
	vec2 rg = unpackHalf2x16(color_a);
	vec2 ba = unpackHalf2x16(color_b);
	return vec4(
		rg.x,
		rg.y,
		ba.x,
		ba.y
	);
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
vec4 sampleTextureRgba32f(in Texture tex, in vec2 uv) {
	uint x = uint(uv.x * float(tex.width));
	uint y = uint(uv.y * float(tex.height));
	x = clamp(x, 0, tex.width - 1);
	y = clamp(y, 0, tex.height - 1);
	uint index = tex.start + (y * tex.width + x) * 4;
	return vec4(
		texture_data[index],
		texture_data[index + 1],
		texture_data[index + 2],
		texture_data[index + 3]
	);
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
vec2 f_getUV(Hit hit_data) {
	return hit_data.uvw.x * vec2(hit_data.hit_tri.uv_a_x, hit_data.hit_tri.uv_a_y) +
	hit_data.uvw.y * vec2(hit_data.hit_tri.uv_b_x, hit_data.hit_tri.uv_b_y) +
	hit_data.uvw.z * vec2(hit_data.hit_tri.uv_c_x, hit_data.hit_tri.uv_c_y);
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
uvec4 seed;
ivec2 pixel;
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
void f_initRNG(ivec2 p, uint frame) {
	seed = uvec4(p.x, p.y, frame, uint(p.x) + uint(p.y));
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
void f_pcg4d(inout uvec4 v) {
	v = v * 1664525u + 1013904223u;
	v.x += v.y * v.w; v.y += v.z * v.x; v.z += v.x * v.y; v.w += v.y * v.z;
	v = v ^ (v >> 16u);
	v.x += v.y * v.w; v.y += v.z * v.x; v.z += v.x * v.y; v.w += v.y * v.z;
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
float f_rand() {
	f_pcg4d(seed); return float(seed.x) / float(0xffffffffu);
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
vec2 f_randUnitDisk() {
	vec2 p;
		do {
			p = 2.0 * vec2(f_rand(), f_rand()) - vec2(1.0, 1.0);
		} while (dot(p, p) >= 1.0);
	return p;
}
bool f_rayLensIntersection(in Ray ray, in Camera_Lens lens, inout float ray_length, out vec3 normal) {
	// Transform ray to camera space
	lens.curvature_radius *= 1.0;
	lens.aperture_radius *= 1.0;
	lens.z_distance *= 1.0;

	vec3 lens_center = (/*camera.position + camera.z_vec * */vec3(0, 0, lens.z_distance));
	vec3 ro = ray.origin - lens_center;

	float a = dot(ray.direction, ray.direction);
	float b = 2.0 * dot(ro, ray.direction);
	float c = dot(ro, ro) - lens.curvature_radius * lens.curvature_radius;
	float t0, t1;

	if (f_quadratic(a,b,c,t0,t1)) {
		float t_dist;
		if (lens.curvature_radius < 0) {
			t_dist = t0;
		}
		else {
			t_dist = t1;
		}

		vec3 hit_point = (ray.origin + ray.direction * t_dist);
		float r2 = hit_point.x * hit_point.x + hit_point.y * hit_point.y;
		if (r2 > lens.aperture_radius * lens.aperture_radius) {
			return false;
		}

		normal = normalize(hit_point - lens_center);
		if (lens.curvature_radius > 0) {
			normal = -normal;
		}
		ray_length = t_dist;
		return true;
	}
	return false;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
bool f_raySphereIntersection(in Ray ray, in Sphere sphere, inout float ray_length) {
	ray.origin = ray.origin - sphere.position;

	float b = dot(ray.origin, ray.direction);
	float delta = b * b - dot(ray.origin, ray.origin) + sphere.diameter * sphere.diameter;
	
	if (delta < 0) {
		return false;
	}
	float sqdelta = sqrt(delta);

	if (-b - sqdelta > EPSILON) {
		ray_length = -b - sqdelta;
		return true;
	}
	else if (-b + sqdelta > EPSILON) {
		ray_length = -b + sqdelta;
		return true;
	}
	return false;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
bool f_rayBvhIntersection(in Ray ray, in Bvh box, inout float ray_length) {
	vec3 f = (box.p_min - ray.origin) * ray.inv_direction;
	vec3 n = (box.p_max - ray.origin) * ray.inv_direction;

	vec3 tmax = max(f, n);
	vec3 tmin = min(f, n);

	float t1 = min(tmax.x, min(tmax.y, tmax.z));
	float t0 = max(tmin.x, max(tmin.y, tmin.z));

	if (t1 >= t0) {
		if (t0 > 0.0f) {
			ray_length = t0;
		}
		else {
			ray_length = t1;
		}
		return true;
	}
	return false;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
bool f_rayTriangleIntersection(in Ray ray, in vec3 vertex_a, in vec3 vertex_b, in vec3 vertex_c, inout float ray_length) {
	vec3 v1v0 = vertex_b - vertex_a;
	vec3 v2v0 = vertex_c - vertex_a;
	vec3 rov0 = ray.origin- vertex_a;

	vec3  normal = cross(v1v0, v2v0);
	vec3  q = cross(rov0, ray.direction);
	float d = 1.0 / dot(ray.direction, normal);
	float u = d * dot(-q, v2v0);
	float v = d * dot(q, v1v0);
	float t = d * dot(-normal, rov0);

	if (u < 0.0 || v < 0.0 || (u + v) > 1.0)
		return false;

	ray_length = t;
	return true;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
bool f_rayTriangleIntersection(in Ray ray, in Triangle tri, inout float ray_length) {
	vec3 v1v0 = tri.pos_b - tri.pos_a;
	vec3 v2v0 = tri.pos_c - tri.pos_a;
	vec3 rov0 = ray.origin- tri.pos_a;

	vec3  normal = cross(v1v0, v2v0);
	vec3  q = cross(rov0, ray.direction);
	float d = 1.0 / dot(ray.direction, normal);
	float u = d * dot(-q, v2v0);
	float v = d * dot(q, v1v0);
	float t = d * dot(-normal, rov0);

	if (u < 0.0 || v < 0.0 || (u + v) > 1.0)
		return false;

	ray_length = t;
	return true;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
float f_rayBvhDist(in Ray ray, in vec3 boxMin, vec3 boxMax) {
	vec3 tMin = (boxMin - ray.origin) * ray.inv_direction;
	vec3 tMax = (boxMax - ray.origin) * ray.inv_direction;
	vec3 t1 = min(tMin, tMax);
	vec3 t2 = max(tMin, tMax);
	float tNear = max(max(t1.x, t1.y), t1.z);
	float tFar = min(min(t2.x, t2.y), t2.z);

	bool hit = tFar >= tNear && tFar > 0;
	float dst = hit ? tNear > 0 ? tNear : 0 : MAX_DIST;
	return dst;
};

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
vec3 f_barycentricCoords(in vec3 hit_pos, in vec3 vertex_a, in vec3 vertex_b, in vec3 vertex_c) {
	vec3 v0 = vertex_b - vertex_a;
	vec3 v1 = vertex_c - vertex_a;
	vec3 v2 = hit_pos  - vertex_a;

	float d00 = dot(v0, v0);
	float d01 = dot(v0, v1);
	float d11 = dot(v1, v1);
	float d20 = dot(v2, v0);
	float d21 = dot(v2, v1);

	float denom = d00 * d11 - d01 * d01;

	float v = (d11 * d20 - d01 * d21) / denom;
	float w = (d00 * d21 - d01 * d20) / denom;
	float u = 1.0 - v - w;

	return vec3(u, v, w);
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
Triangle_Hit_Info f_closestTriangle(in Ray ray, in uint root_node_index) {
	Triangle_Hit_Info result;
	result.triangle_index = MAX_UINT;
	result.hit_distance = MAX_DIST;

	uint stack[32];
	uint stackIndex = 0;
	stack[stackIndex++] = root_node_index + 0;
	
	while (stackIndex > 0) {
		Bvh node = mesh_bvh[stack[--stackIndex]];
		bool isLeaf = node.tri_count < MAX_UINT;

		if (isLeaf) {
			for (uint i = 0; i < node.tri_count; i++) {
				Triangle tri = mesh_triangles[node.pointer + i];
				float dist = MAX_DIST;
				if (f_rayTriangleIntersection(ray, tri, dist)) {
					if (dist < result.hit_distance) {
						result.hit_distance = dist;
						result.triangle_index = node.pointer + i;
					}
				}
			}
		}
		else {
			uint childIndexA = root_node_index + node.pointer + 0;
			uint childIndexB = root_node_index + node.pointer + 1;
			Bvh childA = mesh_bvh[childIndexA];
			Bvh childB = mesh_bvh[childIndexB];

			float dstA = f_rayBvhDist(ray, childA.p_min, childA.p_max);
			float dstB = f_rayBvhDist(ray, childB.p_min, childB.p_max);

			bool  isNearestA = dstA <= dstB;
			float dstNear = isNearestA ? dstA : dstB;
			float dstFar  = isNearestA ? dstB : dstA;
			uint   childIndexNear = isNearestA ? childIndexA : childIndexB;
			uint   childIndexFar  = isNearestA ? childIndexB : childIndexA;

			if (dstFar  < result.hit_distance) stack[stackIndex++] = childIndexFar;
			if (dstNear < result.hit_distance) stack[stackIndex++] = childIndexNear;
		}
	}

	return result;
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
void f_sceneIntersection(in Ray ray, inout Hit hit_data) {
	float t_dist = MAX_DIST;
	float bvh_t_length = MAX_DIST;

	for (uint i = 0; i <= mesh_instances.length(); i++) {
		Triangle_Hit_Info triangle_hit = f_closestTriangle(ray, mesh_instances[i].object_index);
		if (triangle_hit.triangle_index < mesh_triangles.length()) {
			Triangle tri = mesh_triangles[triangle_hit.triangle_index];
			hit_data.t_dist = triangle_hit.hit_distance;
			hit_data.hit_pos = ray.origin + ray.direction * ( triangle_hit.hit_distance - EPSILON);
			hit_data.inside = false;
			hit_data.mesh_hit = true;

			hit_data.uvw = f_barycentricCoords(
				hit_data.hit_pos,
				tri.pos_a,
				tri.pos_b,
				tri.pos_c
			);
			hit_data.material = tri.material;

			hit_data.hit_tri = tri;
			hit_data.hit_normal = hit_data.uvw.x * tri.normal_a + hit_data.uvw.y * tri.normal_b + hit_data.uvw.z * tri.normal_c;
		}
	}
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
vec4 f_hook(inout Hit hit_data, inout State state, inout Ray ray) {
	if (hit_data.material == MAX_UINT) {
		ray.direction = reflect(ray.direction, hit_data.hit_normal);
		ray.origin = hit_data.hit_pos + ray.direction * EPSILON;
		return vec4(0.2, 0.0, 0.2, 1.0);
	}
	else if (hit_data.material == 0) {
		vec2 uv = f_getUV(hit_data);
		vec4 albedo = sampleTextureRgba8u(textures[0], vec2(uv.x, 1 - uv.y));
		Material ganyu_material = Material(
			vec3(1.0)        , // baseColor
			1.0              , // opacity
			ALPHA_MODE_OPAQUE, // alphaMode
			1.0              , // alphaCutoff
			vec3(0.0)        , // emission
			1.0              , // anisotropic
			1.0              , // metallic
			1.0              , // roughness
			1.0              , // subsurface
			1.0              , // specularTint
			1.0              , // sheen
			1.0              , // sheenTint
			1.0              , // clearcoat
			1.0              , // clearcoatRoughness
			1.0              , // specTrans
			1.0              , // ior
			1.0              , // ax
			1.0              , // ay
			Medium(
				MEDIUM_NONE, // type
				1.0,         // density
				vec3(1.0),   // color
				1.0          // anisotropy
			)
		);
		state.material = ganyu_material;
		return albedo;
	}
	// ERROR
	hit_data.error = true;
	return vec4(1, 0, 1, 1);
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
Ray f_cameraNormRay(vec2 uv) {
	vec3 dir = normalize(camera.p_uv + (camera.p_u * uv.x) + (camera.p_v * uv.y) - camera.position);
	return Ray(camera.position, dir, 1.0 / dir);
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
Ray f_cameraRay(vec2 uv) {
	float pixel_size = 1.0 / resolution.x;

	vec3 ray_dir = normalize(camera.p_uv + (camera.p_u * uv.x) + (camera.p_v * uv.y) - camera.position);
	vec3 focal_point = camera.position + ray_dir * camera.focal_distance;

	vec2 aperture_offset = f_randUnitDisk() * pixel_size * camera.aperture * 0.5;
	vec3 lens_offset = camera.position + camera.x_vec * aperture_offset.x + camera.y_vec * aperture_offset.y;
	vec3 new_direction = normalize(focal_point - lens_offset);

	return Ray(camera.position, new_direction, 1.0 / new_direction);
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
Ray f_cameraOrthoRay(vec2 uv) {
	float ortho_scale = 0.05;
	return Ray(camera.position + (camera.p_u * uv.x * ortho_scale) + (camera.p_v * uv.y* ortho_scale), normalize(camera.z_vec), 1.0 / normalize(camera.z_vec));
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
vec4 f_pathTrace(in Ray ray, in ivec2 pixel_id) {
	vec3 radiance = vec3(0.0);
	vec3 throughput = vec3(1.0);
	State state;
	LightSampleRec lightSample;
	BsdfSampleRec bsdfSample;

	vec4 render_output = vec4(0);

	Hit hit_data = f_hit();
	f_sceneIntersection(ray, hit_data);

	render_output = f_hook(hit_data, state, ray);

	return render_output;
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
void f_debugRender(in vec2 uv, in ivec2 pixel_id) {
	Ray ray = f_cameraNormRay(uv);
	Hit hit_data = f_hit();
	f_sceneIntersection(ray, hit_data);

	float bvh_alpha = 1.0;
	for (int i = 0; i < hit_data.bvh_depth; i++) {
		bvh_alpha *= 0.95;
	}
	imageStore(bvh_render_layer, pixel_id, vec4(vec3(1-bvh_alpha), 1));
	imageStore(normal_render_layer, pixel_id, vec4(abs(hit_data.hit_normal), 1));
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
void f_accumulate(in vec4 color, in ivec2 pixel_id) {
	vec4 previous_color = imageLoad(accumulation_render_layer, pixel_id);
	if (current_sample == 0) {
		previous_color = vec4(0);
	}

	float weight = float(current_sample);
	vec4 full_color = (previous_color * weight + color) / (weight + 1.0);
	imageStore(accumulation_render_layer, pixel_id, vec4(full_color.rgb / full_color.a, 1.0));
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
vec4 f_render(in vec2 uv, in ivec2 pixel_id) {
	f_debugRender(uv, pixel_id);

	Ray ray;
	vec4 pixel_color = vec4(0);

	if (camera_lenses.length() == 0) {
		ray = f_cameraRay(uv);
	}
	else {
		ray = f_cameraNormRay(uv);

		float t_dist = MAX_DIST;
		vec3 normal;
		for (uint i = 0; i < camera_lenses.length(); i++) {

			if (f_rayLensIntersection(ray, camera_lenses[i], t_dist, normal)) {
				//pixel_color += vec4(vec3(dot(ray.direction,normal)), 0.5);
				pixel_color += vec4(abs(normal) * 10.1, 1);
				//ray.origin = ray.origin + ray.direction * t_dist;
				//ray.direction = f_refract(ray.direction, normal, 1.0 / camera_lenses[i].ior, 1.0);
			}
		}
	}

	pixel_color += f_pathTrace(ray, pixel_id);
	f_accumulate(pixel_color, pixel_id);

	return pixel_color;
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
void main() {
	ivec2 pixel_id = ivec2(gl_GlobalInvocationID.xy);
	vec2 uv = (pixel_id - 1 - vec2(resolution) / 2.0) / float(max(resolution.x, resolution.y));
	f_initRNG(pixel_id, frame_count);
	vec4 pixel_color = f_render(uv, pixel_id);
	//vec4 pixel_color = mesh_instances.length() > 0 ? vec4(1) : vec4(1,0,1,1);
	imageStore(raw_render_layer, pixel_id, pixel_color);
}
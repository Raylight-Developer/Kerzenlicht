//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
float f_lerp(in float a,in float b, in float t) {
	return a + t * (b - a);
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
vec3 f_lerp(in vec3 a,in vec3 b, in float t) {
	return a + t * (b - a);
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
float f_mapFloat(float from_min, float from_max, float to_min, float to_max, float value) {
	return (to_min + ((to_max - to_min) / (from_max - from_min)) * (value - from_min));
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
float f_mapFloatClamp(float from_min, float from_max, float to_min, float to_max, float value) {
	if (value > from_max) return to_max;
	else if (value < from_min) return to_min;
	else return (to_min + ((to_max - to_min) / (from_max - from_min)) * (value - from_min));
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
vec2 f_mapVec2(vec2 from_min, vec2 from_max, vec2 to_min, vec2 to_max, vec2 value) {
	return vec2(f_mapFloat(from_min.x, from_max.x, to_min.x, to_max.x, value.x), f_mapFloat(from_min.y, from_max.y, to_min.y, to_max.y, value.y));
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
vec3 f_faceForward(vec3 a, vec3 b) {
	return dot(a, b) < 0.0 ? -b : b;
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
float f_luminance(vec3 c) {
	return 0.212671 * c.x + 0.715160 * c.y + 0.072169 * c.z;
}

bool f_quadratic(float A, float B, float C, out float t0, out float t1) {
	float discriminant = B * B - 4.0 * A * C;

	if (discriminant < 0.0) {
		return false;
	}

	float sqrt_discriminant = sqrt(discriminant);
	t0 = (-B - sqrt_discriminant) / (2.0 * A);
	t1 = (-B + sqrt_discriminant) / (2.0 * A);

	return true;
}

vec3 f_refract(vec3 rayDirection, vec3 normal, float iorInside, float iorOutside) {
	float cosi = clamp(dot(normal, -rayDirection), -1.0, 1.0);
	float etai = iorInside;
	float etat = iorOutside;

	// Check if we are entering or exiting
	if (cosi > 0.0) {
		// Swap IORs if we're entering the sphere
		float temp = etai;
		etai = etat;
		etat = temp;
		normal = -normal; // Flip the normal when exiting
	}

	float eta = etai / etat;
	float k = 1.0 - eta * eta * (1.0 - cosi * cosi);
	if (k < 0.0) {
		// Total internal reflection; return no valid refracted ray
		return vec3(0.0); // This could be a direction to handle reflection instead
	} else {
		return eta * rayDirection + (eta * cosi - sqrt(k)) * normal;
	}
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
vec4 f_unpackRgba8u(uint color) {
	return vec4(
		float((color >> 24) & 0xFF) / 255.0,
		float((color >> 16) & 0xFF) / 255.0,
		float((color >> 8) & 0xFF) / 255.0,
		float(color & 0xFF) / 255.0
	);
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
vec4 f_bilinearSampleTextureRgba8u(in Texture tex, in vec2 uv) {
	// Scale UVs to pixel space
	float x = uv.x * float(tex.width) - 0.5;
	float y = uv.y * float(tex.height) - 0.5;

	// Integer coordinates of the top-left texel
	uint x0 = uint(floor(x));
	uint y0 = uint(floor(y));

	// Fractional parts for interpolation
	float fx = fract(x);
	float fy = fract(y);

	// Clamp coordinates to texture bounds
	x0 = clamp(x0, 0u, tex.width - 1u);
	y0 = clamp(y0, 0u, tex.height - 1u);
	uint x1 = min(x0 + 1u, tex.width - 1u);
	uint y1 = min(y0 + 1u, tex.height - 1u);

	// Fetch the four surrounding texels
	uint idx00 = tex.start + y0 * tex.width + x0;
	uint idx10 = tex.start + y0 * tex.width + x1;
	uint idx01 = tex.start + y1 * tex.width + x0;
	uint idx11 = tex.start + y1 * tex.width + x1;

	vec4 color00 = f_unpackRgba8u(KL_BUFFER_texture_data[idx00]);
	vec4 color10 = f_unpackRgba8u(KL_BUFFER_texture_data[idx10]);
	vec4 color01 = f_unpackRgba8u(KL_BUFFER_texture_data[idx01]);
	vec4 color11 = f_unpackRgba8u(KL_BUFFER_texture_data[idx11]);

	// Perform bilinear interpolation
	vec4 color0 = mix(color00, color10, fx);
	vec4 color1 = mix(color01, color11, fx);
	vec4 result = mix(color0, color1, fy);

	return result;
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
vec4 f_sampleTextureRgba8u(in Texture tex, in vec2 uv) {
	uint filtering;
	uint format;
	f_unpackUint(tex.format, format, filtering);

	if (filtering == 1) {
		return f_bilinearSampleTextureRgba8u(tex, uv);
	}

	uint x = uint(uv.x * float(tex.width));
	uint y = uint(uv.y * float(tex.height));

	x = clamp(x, 0, tex.width - 1);
	y = clamp(y, 0, tex.height - 1);

	uint index = tex.start + y * tex.width + x;
	uint color = KL_BUFFER_texture_data[index];

	return f_unpackRgba8u(color);
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
vec4 f_sampleTextureRgba16f(in Texture tex, in vec2 uv) {
	uint x = uint(uv.x * float(tex.width));
	uint y = uint(uv.y * float(tex.height));

	x = clamp(x, 0, tex.width - 1);
	y = clamp(y, 0, tex.height - 1);

	uint index = tex.start + (y * tex.width + x) * 2;
	uint color_a = KL_BUFFER_texture_data[index];
	uint color_b = KL_BUFFER_texture_data[index+1];

	vec2 rg = unpackHalf2x16(color_a);
	vec2 ba = unpackHalf2x16(color_b);

	return vec4(
		rg.x,
		rg.y,
		ba.x,
		ba.y
	);
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
vec4 f_sampleTextureRgba32f(in Texture tex, in vec2 uv) {
	uint x = uint(uv.x * float(tex.width));
	uint y = uint(uv.y * float(tex.height));

	x = clamp(x, 0, tex.width - 1);
	y = clamp(y, 0, tex.height - 1);

	uint index = tex.start + (y * tex.width + x) * 4;

	return vec4(
		KL_BUFFER_texture_data[index],
		KL_BUFFER_texture_data[index + 1],
		KL_BUFFER_texture_data[index + 2],
		KL_BUFFER_texture_data[index + 3]
	);
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
vec4 f_sampleTexture(in Texture tex, in vec2 uv) {
	if (tex.format == TEXTURE_FORMAT_RGBA8u) {
		return f_sampleTextureRgba8u(tex, uv);
	}
	if (tex.format == TEXTURE_FORMAT_RGBA16f) {
		return f_sampleTextureRgba16f(tex, uv);
	}
	if (tex.format == TEXTURE_FORMAT_RGBA32f) {
		return f_sampleTextureRgba32f(tex, uv);
	}
	return vec4(1,0,1,1);
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
vec2 f_getUV(Hit hit_data) {
	return hit_data.uvw.x * vec2(hit_data.hit_tri.uv_a_x, hit_data.hit_tri.uv_a_y) +
	hit_data.uvw.y * vec2(hit_data.hit_tri.uv_b_x, hit_data.hit_tri.uv_b_y) +
	hit_data.uvw.z * vec2(hit_data.hit_tri.uv_c_x, hit_data.hit_tri.uv_c_y);
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
void f_accumulate(in vec4 color, in ivec2 pixel_id) {
	vec4 previous_color = imageLoad(accumulation_render_layer, pixel_id);
	if (current_sample == 0) {
		previous_color = vec4(0);
	}

	float weight = float(current_sample);
	vec4 full_color = (previous_color * weight + color) / (weight + 1.0);
	imageStore(accumulation_render_layer, pixel_id, vec4(full_color.rgb / full_color.a, 1.0));
}
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
vec4 f_render(in vec2 uv, in ivec2 pixel_id) {
	f_debugRender(uv, pixel_id);

	Ray ray = f_cameraNormRay(uv);
	vec4 pixel_color = vec4(0);


	float t_dist = MAX_DIST;
	vec3 normal;
	//for (uint i = 0; i < camera_lenses.length(); i++) {
	uint i = 6;
		if (f_rayLensIntersection(ray, camera_lenses[i], t_dist, normal)) {
			//pixel_color += vec4(vec3(dot(ray.direction,normal)), 0.5);
			pixel_color += vec4(abs(normal), 0.5);
			ray.origin = ray.origin + ray.direction * t_dist;
			ray.direction = f_refract(ray.direction, normal, camera_lenses[i].ior, 1.0);
		}
	//}

	//float t_dist = MAX_DIST;
	//Sphere sphere = Sphere(vec3(0, 0, 1), 0.5);
	//if (f_raySphereIntersection(ray, sphere, t_dist)) {
	//	vec3 normal = normalize(ray.direction * t_dist - sphere.position);
	//	pixel_color = vec4(normal, 1);
	//	//ray.origin = ray.direction * (t_dist + EPSILON);
	//	ray.direction = normalize(refract(ray.direction, normal, 1.0));
	//}



	pixel_color += f_pathTrace(ray, pixel_id);
	f_accumulate(pixel_color, pixel_id);

	return pixel_color;
}
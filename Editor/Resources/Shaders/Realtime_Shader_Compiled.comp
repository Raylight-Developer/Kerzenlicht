#version 450 core

#define TWO_PI   6.28318530718
#define PI       3.14159265359
#define INV_PI   0.31830988618
#define DEG_RAD  0.01745329252
#define PHI      1.61803398874

#define MAX_DIST 10000
#define EPSILON  0.0001

struct Triangle {
	dvec4 v0;
	dvec4 v1;
	dvec4 v2;
};

struct Ray {
	dvec3 origin;
	dvec3 direction;
};

struct Hit {
	double t_dist;
	dvec3    pos;
	dvec3    nor;
	dvec3    uvw;
	Triangle tri;
};

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

layout(rgba8, binding = 0) uniform image2D screen;

layout(std430, binding = 1) buffer TriangleDataBuffer {
	Triangle triangles[];
};

uniform dvec3 camera_pos;
uniform dvec3 camera_p_uv;
uniform dvec3 camera_p_u;
uniform dvec3 camera_p_v;


double f_mapDouble(double from_min, double from_max, double to_min, double to_max, double value) {
	return (to_min + ((to_max - to_min) / (from_max - from_min)) * (value - from_min));
}

bool f_rayTriangleIntersection(in Ray ray, in Triangle tri, inout double ray_length, out dvec3 normal) {
	dvec3 v1v0 = tri.v1.xyz - tri.v0.xyz;
	dvec3 v2v0 = tri.v2.xyz - tri.v0.xyz;
	dvec3 rov0 = ray.origin - tri.v0.xyz;

	normal = cross(v1v0, v2v0);
	dvec3  q = cross(rov0, ray.direction);
	double d = 1 / dot(ray.direction, normal);
	double u = d * dot(-q, v2v0);
	double v = d * dot(q, v1v0);
	double t = d * dot(-normal, rov0);

	if (u < 0 || v < 0 || (u + v) > 1)
		return false;

	ray_length = t;
	return true;
}

dvec3 f_barycentricCoords(in dvec3 hit_pos, in Triangle tri) {
	dvec3 v0 = tri.v1.xyz - tri.v0.xyz;
	dvec3 v1 = tri.v2.xyz - tri.v0.xyz;
	dvec3 v2 = hit_pos - tri.v0.xyz;

	double d00 = dot(v0, v0);
	double d01 = dot(v0, v1);
	double d11 = dot(v1, v1);
	double d20 = dot(v2, v0);
	double d21 = dot(v2, v1);

	double denom = d00 * d11 - d01 * d01;

	double v = (d11 * d20 - d01 * d21) / denom;
	double w = (d00 * d21 - d01 * d20) / denom;
	double u = 1 - v - w;

	return dvec3(u, v, w);
}

Hit f_SceneIntersection(in Ray ray) {
	Hit hit_data;
	hit_data.t_dist = MAX_DIST;
	double t_dist = MAX_DIST;
	dvec3  t_normal;
	for (uint i = 0; i < triangles.length(); i++) {
		if (f_rayTriangleIntersection(ray, triangles[i], t_dist, t_normal)) {
			if (t_dist < hit_data.t_dist && t_dist > EPSILON) {
				hit_data.t_dist = t_dist;
				hit_data.pos = ray.origin + ray.direction * t_dist;
				hit_data.nor = normalize(t_normal);
				hit_data.uvw = f_barycentricCoords(hit_data.pos, triangles[i]);
				hit_data.tri = triangles[i];
			}
		}
	}
	return hit_data;
}


Ray f_cameraRay(dvec2 uv) {
	return Ray(camera_pos, normalize(camera_p_uv + (camera_p_u * uv.x) + (camera_p_v * uv.y)  - camera_pos));
}

dvec3 f_pathTrace(in Ray ray) {
	Hit hit_data = f_SceneIntersection(ray);
	if (hit_data.t_dist != MAX_DIST)
		return dvec3(f_mapDouble(0, 1, 0.3, 0.9, abs(dot(hit_data.nor, ray.direction)))) * pow(float(hit_data.t_dist + 1.0), -0.2) ;//* hit_data.uvw ;
	return dvec3(0.1);
}

void main() {
	ivec2 work_id = ivec2(gl_GlobalInvocationID.xy);
	ivec2 resolution = imageSize(screen);

	dvec2 uv = (dvec2(work_id) - 1.0 - dvec2(resolution) / 2.0) / double(max(resolution.x, resolution.y));
	Ray ray = f_cameraRay(uv);
	imageStore(screen, work_id, vec4(f_pathTrace(ray), 1));
}
